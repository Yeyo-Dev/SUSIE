<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Prueba de Detección Gaze Tracking</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #screen-area {
            position: relative;
            width: 80vw;
            height: 80vh;
            border: 4px dashed #333;
            background: #222;
        }

        #safe-zone {
            position: absolute;
            left: 7.5%;
            /* 1 - 0.85 = 0.15 / 2 = 0.075 */
            top: 7.5%;
            width: 85%;
            height: 85%;
            border: 2px solid #00ff00;
            background: rgba(0, 255, 0, 0.05);
            pointer-events: none;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: rgba(0, 255, 0, 0.3);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            font-size: 2rem;
            text-align: center;
        }

        #gaze-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            transition: all 0.1s;
            box-shadow: 0 0 10px red;
            z-index: 10;
        }

        #info {
            margin-top: 10px;
            font-size: 1.2rem;
            display: flex;
            gap: 20px;
        }

        .status-ok {
            color: #00ff00;
        }

        .status-out {
            color: #ff0000;
            font-weight: bold;
        }

        #timer-bar {
            width: 100%;
            height: 10px;
            background: #444;
            position: fixed;
            bottom: 0;
            left: 0;
        }

        #timer-fill {
            height: 100%;
            width: 0%;
            background: red;
            transition: width 0.1s;
        }

        #controls {
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            background: #0088cc;
            color: white;
            border: none;
            border-radius: 5px;
        }

        button:hover {
            background: #006699;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h2>Herramienta de Calibración Gaze</h2>
        <p>1. Inicia WebGazer.<br>2. <b>¡Haz clic por toda la pantalla repetidas veces!</b> (esquinas, bordes, centro)
            mientras miras tu ratón.<br>3. Termina la calibración para probar.</p>
        <button id="btn-start">1. Iniciar WebGazer</button>
        <button id="btn-calibrate" disabled>2. Terminar Calibración</button>
    </div>

    <div id="screen-area">
        <div id="safe-zone">ZONA SEGURA (85%)<br>Umbral: 0.85</div>
        <div id="gaze-dot"></div>
    </div>

    <div id="info">
        <div>Coordenadas Escala [-1, 1]: <span id="val-xy">X: 0.00, Y: 0.00</span></div>
        <div>Estado: <span id="val-status" class="status-ok">DENTRO PANTALLA</span></div>
    </div>

    <div id="timer-bar">
        <div id="timer-fill"></div>
    </div>

    <!-- Usando la copia local de webgazer con mediapipe -->
    <script src="projects/susie-demo/src/assets/webgazer.js"></script>
    <script>
        const dot = document.getElementById('gaze-dot');
        const valXY = document.getElementById('val-xy');
        const valStatus = document.getElementById('val-status');
        const timerFill = document.getElementById('timer-fill');
        const btnStart = document.getElementById('btn-start');
        const btnCalibrate = document.getElementById('btn-calibrate');

        // Configuración igual a la de SUSIE
        const THRESHOLD = 0.85;
        const TOLERANCE_MS = 5000;

        let outOfBoundsStartTime = null;

        // Historial para suavizado
        const xHistory = [];
        const yHistory = [];
        const SMOOTHING_WINDOW = 10;

        btnStart.onclick = async () => {
            if (!window.webgazer) {
                alert("WebGazer no cargó.");
                return;
            }
            btnStart.disabled = true;
            btnStart.innerText = "Iniciando...";

            await window.webgazer
                .setTracker('TFFacemesh')
                .setRegression('ridge')
                .setGazeListener((data) => {
                    if (!data) return;
                    processGaze(data.x, data.y);
                })
                .begin();

            window.webgazer.showVideoPreview(true).showPredictionPoints(true);
            btnStart.style.display = 'none';
            btnCalibrate.disabled = false;
        };

        btnCalibrate.onclick = () => {
            btnControls = document.getElementById('controls');
            btnControls.style.display = 'none';

            // Simular lo que hace nuestra app
            document.getElementById('webgazerVideoContainer').style.opacity = '1';
            document.getElementById('webgazerVideoContainer').style.position = 'fixed';
            document.getElementById('webgazerVideoContainer').style.top = '-9999px';
            document.getElementById('webgazerVideoContainer').style.left = '-9999px';
        };

        // Escucha clics para simular calibración genuina de WebGazer
        document.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                // Registrar el click oficial para webgazer
                if (window.webgazer && typeof window.webgazer.recordScreenPosition === 'function') {
                    window.webgazer.recordScreenPosition(e.clientX, e.clientY, 'click');
                }

                // Punto de feedback visual (azul para que destace)
                const d = document.createElement('div');
                d.style.position = 'absolute';
                d.style.width = '15px'; d.style.height = '15px'; d.style.background = '#00aaff';
                d.style.borderRadius = '50%';
                d.style.left = e.pageX + 'px'; d.style.top = e.pageY + 'px';
                d.style.transform = 'translate(-50%, -50%)';
                d.style.zIndex = '9999';
                document.body.appendChild(d);
                setTimeout(() => d.style.opacity = '0', 300);
                setTimeout(() => d.remove(), 800);
            }
        });

        function processGaze(rawX, rawY) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Escalar a [-1, 1]
            const scaledX = (rawX / width) * 2 - 1;
            const scaledY = (rawY / height) * 2 - 1;

            xHistory.push(scaledX);
            yHistory.push(scaledY);
            if (xHistory.length > SMOOTHING_WINDOW) {
                xHistory.shift(); yHistory.shift();
            }

            const avgX = xHistory.reduce((a, b) => a + b) / xHistory.length;
            const avgY = yHistory.reduce((a, b) => a + b) / yHistory.length;

            updateVisuals(avgX, avgY);
        }

        function updateVisuals(x, y) {
            valXY.innerText = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`;

            // Mapear [-1, 1] al CSS (0% a 100%)
            const percentX = ((x + 1) / 2) * 100;
            const percentY = ((y + 1) / 2) * 100;

            // Limitar el punto para que no se salga ridículamente de la pantalla visible
            dot.style.left = Math.max(-50, Math.min(150, percentX)) + '%';
            dot.style.top = Math.max(-50, Math.min(150, percentY)) + '%';

            // Comprobar umbral
            const isOut = Math.abs(x) > THRESHOLD || Math.abs(y) > THRESHOLD;

            if (isOut) {
                if (!outOfBoundsStartTime) {
                    outOfBoundsStartTime = Date.now();
                }
                const elapsed = Date.now() - outOfBoundsStartTime;

                valStatus.innerText = `FUERA DEL UMBRAL (${(elapsed / 1000).toFixed(1)}s)`;
                valStatus.className = 'status-out';

                // Mover barra de tiempo
                const percentage = Math.min(100, (elapsed / TOLERANCE_MS) * 100);
                timerFill.style.width = percentage + '%';

                if (elapsed >= TOLERANCE_MS) {
                    timerFill.style.background = 'magenta';
                    valStatus.innerText = '¡ALERTA DE DESVIACIÓN DISPARADA!';
                } else {
                    timerFill.style.background = 'red';
                }

            } else {
                outOfBoundsStartTime = null;
                valStatus.innerText = 'DENTRO PANTALLA';
                valStatus.className = 'status-ok';
                timerFill.style.width = '0%';
            }
        }
    </script>
</body>

</html>